<!DOCTYPE html>
<meta charset="utf-8" />
<html lang="en">

<head>
    <title>: [ O ] :</title>
    <script src="https://code.jquery.com/jquery-2.2.4.min.js" type="text/javascript"></script>

    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Philosopher">
    <link rel="stylesheet" href="./metamedia.css" />
    <script src="./build/three.js"></script>
    <script src="js/libs/stats.min.js"></script>
    <script src="js/libs/dat.gui.min.js"></script>
    <script src="js/crossfade/gui.js"></script>
    <script src="js/crossfade/transition.js"></script>
    <script src="js/utils/BufferGeometryUtils.js"></script>
    <script>var sunbox = "./skyboxsun5deg2.png";</script>
</head>

<body>
<div id="container"></div>
        <button id='topButton' value="r" onClick="Aclicker()" style="visibility: hidden" />
        <button id="hideButton" value="y" onClick="shifty()" style="visibility: hidden">X</button>
        <input type="button" id='mainButton' value="" style="visibility: hidden" />


        <canvas id="bigCanvas" style="visibility: hidden"></canvas>
        <div id="showtags" style="visibility: hidden"> </div>
        <div id="chariCard" class="card-container" style="visibility: hidden"> </div>
        <div id="shimBtm" style="visibility: hidden"></div>

        <input type="search" id='shim' style="visibility: hidden" placeholder="#search" />
        <input type='submit' value="?" style="visibility: hidden" id='searchButton' />
        <input type='submit' value="?" style="visibility: hidden" id='searchButton2' />
        <div id="searches" style="visibility: hidden"> </div>


    <div id="cardTwo" class="card">
        <div class="card-content">
            <h1>M e t a M e d i a</h1>
            <h3>An Interactive Portfolio Of Commercial Development</h3>
            <h1><a href="#">UI Architect: Ryan Walsh</a></h1>
            <h1><a href="#">UX Designer: Jack Walsh</a></h1>
            <h3 style="background-color: rgba(255, 255, 255, 0.0);">(c)2019 All Rights Reserved</h3>
        </div>
    </div>

    <div class="footer">
        <div class="footer-content">
        <a id="resetButton" href='#' onClick="transitionOne()"><h2>Entertainment</h2></a>
        <a href="./ph/"><h2>Marketing</h2></a>
        <a href="#"><h2>Corporate</h2></a>
        <a href="./ph/"><h2>Mobile Apps</h2></a>
        <a href="./port"><h2>Industrial Design</h2></a>
            <a href="#"><h2>Code Browser</h2></a>
<!--    <a href="https://play.google.com/store/apps/developer?id=Castlehale+Group+Ltd" target="_blank">App</a> -->
        </div>
    </div>

<script>

    function transitionOne(){
        //scene.js
        function generateGeometry( objectType, numObjects ) {

            function applyVertexColors( geometry, color ) {

                var position = geometry.attributes.position;
                var colors = [];

                for ( var i = 0; i < position.count; i ++ ) {

                    colors.push( color.r, color.g, color.b );

                }

                geometry.addAttribute( 'color', new THREE.Float32BufferAttribute( colors, 3 ) );

            }

            var geometries = [];

            var matrix = new THREE.Matrix4();
            var position = new THREE.Vector3();
            var rotation = new THREE.Euler();
            var quaternion = new THREE.Quaternion();
            var scale = new THREE.Vector3();
            var color = new THREE.Color();

            for ( var i = 0; i < numObjects; i ++ ) {

                position.x = Math.random() * 10000 - 5000;
                position.y = Math.random() * 6000 - 3000;
                position.z = Math.random() * 8000 - 4000;

                rotation.x = Math.random() * 2 * Math.PI;
                rotation.y = Math.random() * 2 * Math.PI;
                rotation.z = Math.random() * 2 * Math.PI;
                quaternion.setFromEuler( rotation, false );

                scale.x = Math.random() * 200 + 100;

                var geometry;

                if ( objectType === 'cube' ) {

                    geometry = new THREE.BoxBufferGeometry( 1, 1, 1 );
                    geometry = geometry.toNonIndexed(); // merging needs consistent buffer geometries
                    scale.y = Math.random() * 200 + 100;
                    scale.z = Math.random() * 200 + 100;
                    color.setRGB( 0, 0, 0.1 + 0.9 * Math.random() );

                } else if ( objectType === 'sphere' ) {

                    geometry = new THREE.IcosahedronBufferGeometry( 1, 1 );
                    scale.y = scale.z = scale.x;
                    color.setRGB( 0.1 + 0.9 * Math.random(), 0, 0 );

                }

                // give the geom's vertices a random color, to be displayed
                applyVertexColors( geometry, color );

                matrix.compose( position, quaternion, scale );
                geometry.applyMatrix( matrix );

                geometries.push( geometry );

            }

            return THREE.BufferGeometryUtils.mergeBufferGeometries(geometries);

        }

        function Scene( type, numObjects, cameraZ, fov, rotationSpeed, clearColor ) {

            this.clearColor = clearColor;

            this.camera = new THREE.PerspectiveCamera( fov, window.innerWidth / window.innerHeight, 1, 10000 );
            this.camera.position.z = cameraZ;

            // Setup scene
            this.scene = new THREE.Scene();
            this.scene.add( new THREE.AmbientLight( 0x555555 ) );

            var light = new THREE.SpotLight( 0xffffff, 1.5 );
            light.position.set( 0, 500, 2000 );
            this.scene.add( light );

            this.rotationSpeed = rotationSpeed;

            var defaultMaterial = new THREE.MeshPhongMaterial( { color: 0xffffff, flatShading: true, vertexColors: THREE.VertexColors } );
            this.mesh = new THREE.Mesh( generateGeometry( type, numObjects ), defaultMaterial );
            this.scene.add( this.mesh );

            var renderTargetParameters = { minFilter: THREE.LinearFilter, magFilter: THREE.LinearFilter, format: THREE.RGBFormat, stencilBuffer: false };
            this.fbo = new THREE.WebGLRenderTarget( window.innerWidth, window.innerHeight, renderTargetParameters );

            this.render = function ( delta, rtt ) {

                this.mesh.rotation.x += delta * this.rotationSpeed.x;
                this.mesh.rotation.y += delta * this.rotationSpeed.y;
                this.mesh.rotation.z += delta * this.rotationSpeed.z;

                renderer.setClearColor( this.clearColor );

                if ( rtt ) {

                    renderer.setRenderTarget( this.fbo );
                    renderer.clear();
                    renderer.render( this.scene, this.camera );

                } else {

                    renderer.setRenderTarget( null );
                    renderer.render( this.scene, this.camera );

                }

            };

        }//scene.js


        var container;
        var renderer;
        var transition;

        var clock = new THREE.Clock();

        init();
        animate();

        function init() {

            initGUI();

            var cardTwo = document.getElementById( "cardTwo" );

            renderer = new THREE.WebGLRenderer( { antialias: true } );
            renderer.setPixelRatio( window.devicePixelRatio );
            renderer.setSize( cardTwo.innerWidth, cardTwo.innerHeight );
            cardTwo.appendChild( renderer.domElement );

            //stats = new Stats();
            //container.appendChild( stats.dom );

             sceneA = new Scene( "cube", 5000, 1200, 120, new THREE.Vector3( 0, - 0.4, 0 ), 0xffffff );
             sceneB = new Scene( "sphere", 500, 2000, 50, new THREE.Vector3( 0, 0.2, 0.1 ), 0x000000 );

            transition = new Transition( sceneA, sceneB );

        }

        function animate() {
            requestAnimationFrame( animate );
            render();
        }

        function render() {
            transition.render( clock.getDelta() );
        }
    }
    </script>

<!--that's all folks-->
<script>
    var card = $(".card");
    //var container2 = $(".footer");
    $(document).on("mousemove",function(e) {
        var ax = -($(window).innerWidth()/2- e.pageX)/25;
        var ay = ($(window).innerHeight()/2- e.pageY)/25;
      //if (card.attr("style", "visibilty") !== "hidden"){
            card.attr("style", "transform: rotateY(" + ax + "deg) rotateX(" + ay + "deg);-webkit-transform: rotateY(" + ax + "deg) rotateX(" + ay + "deg);-moz-transform: rotateY(" + ax + "deg) rotateX(" + ay + "deg)");

      //  }

    //    container2.attr("style", "transform: rotateY("+ax+"deg) rotateX("+ay+"deg);-webkit-transform: rotateY("+ax+"deg) rotateX("+ay+"deg);-moz-transform: rotateY("+ax+"deg) rotateX("+ay+"deg)");
    })
</script>

<!--  only scripts below this line!!    -->
<script src="./js/jquery.min.js" type="text/javascript"></script>
<script src="three.js"></script>

<script src="Detector.js"></script>
<script src="DeviceOrientationControls.js"></script>
<script src="VRControls.js"></script>

<script src="OrbitControls.js"></script>
<script src="Mirror.js"></script>
<script src="WaterShader.js"></script>


<script>
    if (!Detector.webgl) {
        Detector.addGetWebGLMessage();
        document.getElementById('container').innerHTML = "";
    }
    var container, stats;
    var camera, scene, renderer;
    var sphere;
    var parameters = {
        width: 2000,
        height: 2000,
        widthSegments: 250,
        heightSegments: 250,
        depth: 1500,
        param: 4,
        filterparam: 1
    };
    var waterNormals;

    init();
    animate();

    function init() {
        container = document.createElement('div');
        document.body.appendChild(container);
        renderer = new THREE.WebGLRenderer();
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        container.appendChild(renderer.domElement);
        scene = new THREE.Scene();
        camera = new THREE.PerspectiveCamera(55, window.innerWidth / window.innerHeight, 0.5, 3000000);
        camera.position.set(2000, 750, 2000);
        controls = new THREE.OrbitControls(camera, renderer.domElement);
        //controls = new THREE.DeviceOrientationControls(camera, renderer.domElement);
        //controls = new THREE.VRControls(camera, renderer.domElement);

        controls.enablePan = false;
        controls.minDistance = 1000.0;
        controls.maxDistance = 5000.0;
        controls.maxPolarAngle = Math.PI * 0.495;
        controls.target.set(0, 500, 0);
        scene.add(new THREE.AmbientLight(0x444444));
        var light = new THREE.DirectionalLight(0xffffbb, 1);
        light.position.set(-1, 1, -1);
        scene.add(light);
        waterNormals = new THREE.TextureLoader().load('waternormals.jpg');
        waterNormals.wrapS = waterNormals.wrapT = THREE.RepeatWrapping;
        water = new THREE.Water(renderer, camera, scene, {
            textureWidth: 512,
            textureHeight: 512,
            waterNormals: waterNormals,
            alpha: 1.0,
            sunDirection: light.position.clone().normalize(),
            sunColor: 0xffffff,
            waterColor: 0x001e0f,
            distortionScale: 50.0,
        });
        mirrorMesh = new THREE.Mesh(
            new THREE.PlaneBufferGeometry(parameters.width * 500, parameters.height * 500),
            water.material
        );
        mirrorMesh.add(water);
        mirrorMesh.rotation.x = -Math.PI * 0.5;
        scene.add(mirrorMesh);
        // load skybox
        var cubeMap = new THREE.CubeTexture([]);
        cubeMap.format = THREE.RGBFormat;
        var loader = new THREE.ImageLoader();
        loader.load(sunbox, function(image) {
            var getSide = function(x, y) {
                var size = 1024;
                var canvas = document.createElement('canvas');
                canvas.width = size;
                canvas.height = size;
                var context = canvas.getContext('2d');
                context.drawImage(image, -x * size, -y * size);

                function resizeCanvas() {
                    $(document).width = window.innerWidth;
                    $(document).height = window.innerHeight;
                }
                window.addEventListener('resize', resizeCanvas, false);
                window.addEventListener('resize', onWindowResize, false);

                function onWindowResize() {

                    camera.aspect = window.innerWidth / window.innerHeight;
                    camera.updateProjectionMatrix();

                    renderer.setSize(window.innerWidth, window.innerHeight);
                }
                return canvas;
            };
            cubeMap.images[0] = getSide(2, 1); // px
            cubeMap.images[1] = getSide(0, 1); // nx
            cubeMap.images[2] = getSide(1, 0); // py
            cubeMap.images[3] = getSide(1, 2); // ny
            cubeMap.images[4] = getSide(1, 1); // pz
            cubeMap.images[5] = getSide(3, 1); // nz
            cubeMap.needsUpdate = true;
        });
        var cubeShader = THREE.ShaderLib['cube'];
        cubeShader.uniforms['tCube'].value = cubeMap;
        var skyBoxMaterial = new THREE.ShaderMaterial({
            fragmentShader: cubeShader.fragmentShader,
            vertexShader: cubeShader.vertexShader,
            uniforms: cubeShader.uniforms,
            depthWrite: false,
            side: THREE.BackSide
        });
        var skyBox = new THREE.Mesh(
            new THREE.BoxGeometry(1000000, 1000000, 1000000),
            skyBoxMaterial
        );
        scene.add(skyBox);
        var geometry = new THREE.IcosahedronGeometry(400, 4);
        for (var i = 0, j = geometry.faces.length; i < j; i++) {
            geometry.faces[i].color.setHex(Math.random() * 0xffffff);
        }
        var material = new THREE.MeshPhongMaterial({
            vertexColors: THREE.FaceColors,
            shininess: 100,
            envMap: cubeMap
        });

    }
    //
    function animate() {
        requestAnimationFrame(animate);
        render();
    }

    function render() {
        var time = performance.now() * 0.001;

        water.material.uniforms.time.value += 1.0 / 60.0;
        controls.update();
        water.render();
        renderer.render(scene, camera);
    }
</script>
<script>
    window.addEventListener( 'resize', onWindowResize, false );

    function onWindowResize(){

        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();

        renderer.setSize( window.innerWidth, window.innerHeight );

    }
</script>
    <script src="./js/jquery.tagcanvas.min.js" type="text/javascript"></script>
    <script src="./js/Detector.js" type="text/javascript"></script>
    <script src="./js/hs.js" type="text/javascript"></script>
    <script src="./js/fresco.js" type="text/javascript"></script>
    <script src="./ab/js/prot4usA.js"></script>


</body>

</html>